# 5-4-コーディング規約

## 1. 概要

本ドキュメントは、train-traineeプロジェクトにおけるコーディング規約を定義します。
すべての開発者が一貫性のある、保守性の高いコードを書くためのガイドラインです。

### 1.1 目的

- コードの一貫性と可読性の向上
- 保守性の確保
- チーム内でのコード理解の促進
- バグの早期発見と防止
- コードレビューの効率化

### 1.2 適用範囲

- Javaソースコード
- 設定ファイル（properties, yaml）
- SQLファイル
- テストコード

## 2. ファイル構成

### 2.1 ディレクトリ構造

```
src/main/java/com/javatraining/backend/
├── controller/      # Webコントローラー
├── service/        # ビジネスロジック
├── repository/     # データアクセス層
├── entity/         # エンティティクラス
├── dto/           # データ転送オブジェクト
├── config/        # 設定クラス
├── exception/     # カスタム例外
└── util/          # ユーティリティクラス
```

### 2.2 ファイル命名規則

- Javaファイル: `PascalCase.java`（例: `UserController.java`）
- プロパティファイル: `lowercase-kebab-case.properties`（例: `application-dev.properties`）
- SQLファイル: `V{version}_{description}.sql`（例: `V1__Create_users_table.sql`）

## 3. 命名規則

### 3.1 基本規則

| 種類 | 規則 | 例 |
|------|------|-----|
| クラス名 | PascalCase | `UserController`, `UserService` |
| インターフェース名 | PascalCase | `UserRepository`, `Validator` |
| メソッド名 | camelCase | `getUserById`, `updateUser` |
| 変数名 | camelCase | `userName`, `maxRetryCount` |
| 定数 | UPPER_SNAKE_CASE | `MAX_TAG_COUNT`, `DEFAULT_STATUS` |
| パッケージ名 | lowercase | `com.javatraining.backend` |

### 3.2 詳細な命名規則

#### 3.2.1 クラス名・インターフェース名

```java
// クラス名: 名詞、単数形、役割を明確に表す
public class UserController { }      // ✅ 良い
public class UsersControl { }        // ❌ 悪い（複数形、略語）

// インターフェース名: 形容詞または名詞
public interface Validator { }       // ✅ 良い
public interface Validatable { }     // ✅ 良い
```

#### 3.2.2 メソッド名

```java
// 動詞で始める、処理内容を明確に表す
public User getUserById(Long id) { }           // ✅ 良い（get + 対象 + 条件）
public List<User> findActiveUsers() { }        // ✅ 良い（find + 条件 + 対象）
public void deleteUser(Long id) { }            // ✅ 良い（動詞 + 対象）
public boolean isActive() { }                  // ✅ 良い（is/has + 状態）

public User get(Long id) { }                   // ❌ 悪い（何を取得するか不明）
public void process() { }                      // ❌ 悪い（処理内容が不明）
```

#### 3.2.3 変数名

```java
// 意味のある名前、略語を避ける
String userName = "田中太郎";                   // ✅ 良い
List<UserTag> activeUserTags = new ArrayList<>();  // ✅ 良い
int maxRetryCount = 3;                         // ✅ 良い

String n = "田中太郎";                          // ❌ 悪い（意味不明）
List<UserTag> list = new ArrayList<>();        // ❌ 悪い（汎用的すぎる）
int cnt = 3;                                   // ❌ 悪い（不必要な略語）
```

#### 3.2.4 定数

```java
// 全て大文字、単語間はアンダースコア
private static final int MAX_TAG_COUNT = 4;
private static final String DEFAULT_STATUS = "有効";
private static final long CACHE_TIMEOUT_SECONDS = 3600L;
```

## 4. インポート文

### 4.1 インポートの順序

インポート文は以下の順序で記載し、各グループ間に空行を入れる：

```java
// 1. Java標準ライブラリ
import java.util.List;
import java.util.Map;

// 2. Jakartaライブラリ
import jakarta.persistence.Entity;
import jakarta.validation.Valid;

// 3. サードパーティライブラリ
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.GetMapping;

// 4. プロジェクト内部クラス
import com.javatraining.backend.entity.User;
import com.javatraining.backend.service.UserService;

// 5. 静的インポート
import static org.junit.jupiter.api.Assertions.*;
```

### 4.2 ワイルドカードインポートの禁止

ワイルドカードインポート（`*`）は使用しない。すべてのクラスを明示的にインポートする。

```java
// ❌ 悪い例
import java.util.*;
import org.springframework.web.bind.annotation.*;

// ✅ 良い例
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
```

**例外**: テストクラスの静的インポートは可とする
```java
// テストクラスでは許可
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;
```

### 4.3 未使用インポートの削除

未使用のインポート文は削除する。IDEの自動整形機能を活用する。

## 5. コメント規約

### 5.1 基本原則

- **日本語で記述**（プロジェクトポリシー）
- **「なぜ」を説明**（「何を」はコードで明確にする）
- **簡潔で分かりやすく**
- **コードと同期を保つ**（古いコメントは削除）

### 5.2 Javadocコメント

#### 5.2.1 クラス・インターフェース

```java
/**
 * ユーザー管理サービス
 * ユーザーの作成、更新、削除、検索などのビジネスロジックを提供する
 * 
 * @author 開発者名
 * @since 1.0.0
 */
@Service
@Transactional
public class UserService {
```

#### 5.2.2 メソッド

```java
/**
 * ユーザーを検索条件に基づいて取得する
 * 論理削除されたユーザーは除外される
 * 
 * @param search 検索キーワード（名前またはメールアドレスの部分一致）
 * @param category カテゴリーフィルタ（nullの場合は全カテゴリー）
 * @param status ステータスフィルタ（nullの場合は全ステータス）
 * @param page ページ番号（0から開始）
 * @param size ページサイズ
 * @return 検索結果のページ情報
 * @throws IllegalArgumentException 無効なパラメータの場合
 */
public Page<User> findUsersWithFilters(String search, String category, 
                                       String status, int page, int size) {
```

### 5.3 実装コメント

```java
// ✅ 良いコメントの例
// N+1問題を回避するため、バッチフェッチを使用
List<UserTag> allTags = userTagRepository.findActiveByUserIds(userIds);

// 論理削除のため、削除日時をセット（物理削除は行わない）
user.setDeletedAt(LocalDateTime.now());

// メールアドレスの重複チェック（論理削除されたユーザーは除外）
if (userRepository.existsByEmailAndDeletedAtIsNull(email)) {

// ❌ 悪いコメントの例
// userIdをセットする
user.setUserId(userId);

// ループ処理
for (User user : users) {

// nullチェック
if (user != null) {
```

## 6. フォーマット規約

### 6.1 インデント

- **4スペース**を使用（タブは使用しない）
- IDEの自動フォーマット設定を統一

### 6.2 行の長さ

- 1行は**120文字**以内を推奨
- 長いメソッドチェーンは適切に改行

```java
// ✅ 良い例
List<UserTag> tags = users.stream()
    .map(User::getId)
    .distinct()
    .flatMap(id -> tagRepository.findByUserId(id).stream())
    .filter(tag -> tag.isActive())
    .collect(Collectors.toList());
```

### 6.3 中括弧の使用

- **K&Rスタイル**（開き括弧は同じ行）
- 単一文でも中括弧を使用

```java
// ✅ 良い例
if (user.isActive()) {
    processUser(user);
}

// ❌ 悪い例
if (user.isActive())
    processUser(user);  // 中括弧なし

if (user.isActive())
{                      // 開き括弧が次の行
    processUser(user);
}
```

### 6.4 空白行

- メソッド間: 1行
- import文のグループ間: 1行
- クラス内の論理的なセクション間: 1行

## 7. 非推奨コードの取り扱い

### 7.1 非推奨アノテーションの回避

最新のAPIを使用し、非推奨（deprecated）のクラス・メソッドは使用しない。

```java
// ❌ 非推奨 (Hibernate 6.3以降)
@Where(clause = "deleted_at IS NULL")

// ✅ 推奨
@SQLRestriction("deleted_at IS NULL")

// ❌ 非推奨 (Spring Boot 3.4以降)
@MockBean
private UserService userService;

// ✅ 推奨
@MockitoBean
private UserService userService;

// ❌ 非推奨 (Java 9以降)
new Integer(10)

// ✅ 推奨
Integer.valueOf(10)
```

### 7.2 ライブラリのアップデート

- 定期的に依存ライブラリを更新
- 非推奨警告が出たら速やかに対応
- マイグレーションガイドを参照

## 8. エラーハンドリング規約

### 8.1 例外処理の基本

```java
// サービス層の例
@Service
@Transactional
public class UserService {
    
    public User createUser(User user) {
        try {
            // ビジネスロジック
            validateUserEmail(user.getEmail());
            User savedUser = userRepository.save(user);
            logger.info("ユーザー作成成功: ID={}", savedUser.getId());
            return savedUser;
            
        } catch (IllegalArgumentException e) {
            // ビジネスルール違反はそのまま再スロー
            throw e;
        } catch (Exception e) {
            // 予期しないエラーはログ出力後に適切な例外で包む
            logger.error("ユーザー作成エラー: {}", e.getMessage(), e);
            throw new RuntimeException("ユーザーの作成に失敗しました", e);
        }
    }
}
```

### 8.2 nullチェック

```java
// ✅ 良い例 - Optionalを活用
public String getUserName(Long userId) {
    return userRepository.findById(userId)
        .map(User::getUserName)
        .orElseThrow(() -> new IllegalArgumentException("ユーザーが見つかりません: " + userId));
}

// ❌ 悪い例 - NullPointerExceptionのリスク
public String getUserName(Long userId) {
    User user = userRepository.findById(userId).get();
    return user.getUserName();
}
```

## 9. テストコード規約

### 9.1 テストメソッド名

```java
// 日本語の@DisplayNameを使用
@Test
@DisplayName("ユーザー作成成功テスト")
void testCreateUserSuccess() {
    // テスト実装
}

@Test
@DisplayName("メールアドレス重複時の例外テスト")
void testCreateUserDuplicateEmail() {
    // テスト実装
}
```

### 9.2 テスト構造

```java
@Test
@DisplayName("ユーザー更新テスト")
void testUpdateUser() {
    // 準備（Arrange）
    User existingUser = createTestUser();
    when(userRepository.findById(1L)).thenReturn(Optional.of(existingUser));
    
    // 実行（Act）
    User updatedUser = userService.updateUser(1L, updateData);
    
    // 検証（Assert）
    assertEquals("更新後の名前", updatedUser.getUserName());
    verify(userRepository).save(any(User.class));
}
```

## 10. Gitコミット規約

### 10.1 コミットメッセージ形式

```
<type>: <subject>

<body>

<footer>
```

### 10.2 タイプ

- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメント変更
- `style`: コードスタイル変更（フォーマット等）
- `refactor`: リファクタリング
- `test`: テスト追加・修正
- `chore`: ビルド処理やツールの変更

### 10.3 例

```
feat: ユーザータグ機能を追加

- 最大4個までタグを設定可能
- 論理削除対応
- N+1問題を考慮したバッチフェッチ実装

Closes #123
```

## 11. セキュリティ規約

### 11.1 SQLインジェクション対策

```java
// ❌ 危険 - SQLインジェクションの脆弱性
String sql = "SELECT * FROM users WHERE name = '" + userName + "'";

// ✅ 安全 - パラメータバインディング使用
@Query("SELECT u FROM User u WHERE u.userName = :userName")
Optional<User> findByUserName(@Param("userName") String userName);
```

### 11.2 機密情報の取り扱い

```java
// ❌ 悪い例 - パスワードをログ出力
logger.info("ログイン試行: email={}, password={}", email, password);

// ✅ 良い例 - 機密情報は記録しない
logger.info("ログイン試行: email={}", email);
```

## 12. コードレビューチェックリスト

コードレビュー時に確認すべき項目：

### 基本事項
- [ ] 命名規則に従っているか
- [ ] ワイルドカードインポートを使用していないか
- [ ] 未使用のインポート・変数・メソッドがないか
- [ ] 適切なコメントが記載されているか（日本語）

### 品質
- [ ] エラーハンドリングが適切か
- [ ] nullチェックが実装されているか
- [ ] N+1問題が発生していないか
- [ ] トランザクション管理は適切か

### セキュリティ
- [ ] SQLインジェクション対策がされているか
- [ ] 機密情報がログに出力されていないか
- [ ] 入力値のバリデーションが実装されているか

### パフォーマンス
- [ ] 不要なデータベースアクセスがないか
- [ ] 適切なインデックスが使用されているか
- [ ] メモリリークの可能性がないか

### テスト
- [ ] 単体テストが書かれているか
- [ ] 正常系・異常系のテストケースが網羅されているか
- [ ] テストが独立して実行可能か

## 13. IDEの設定

### 13.1 IntelliJ IDEA

```
Settings > Editor > Code Style > Java
- Tab size: 4
- Indent: 4
- Use tab character: OFF
- Class count to use import with '*': 99（実質無効化）
- Names count to use static import with '*': 99（実質無効化）
```

### 13.2 Eclipse

```
Preferences > Java > Code Style > Formatter
- Tab policy: Spaces only
- Indentation size: 4
- Tab size: 4
```

### 13.3 自動フォーマット

- 保存時に自動フォーマットを有効化
- チーム内で設定ファイルを共有（`.editorconfig`等）

## まとめ

このコーディング規約は、チーム全体でコードの品質を維持し、保守性を高めるためのガイドラインです。
すべての開発者がこの規約に従うことで、以下のメリットが得られます：

- 👥 **チーム開発の効率化** - 統一されたコードスタイルにより理解が容易
- 🐛 **バグの削減** - 一貫した実装パターンによりミスを防止
- 📖 **可読性の向上** - 誰が見ても理解しやすいコード
- 🔧 **保守性の確保** - 長期的なメンテナンスが容易

定期的にこの規約を見直し、チームの成長とともに改善していくことが重要です。