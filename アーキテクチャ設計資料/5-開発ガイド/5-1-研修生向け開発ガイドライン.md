# 5-1-研修生向け開発ガイドライン

## 1. はじめに

このドキュメントは、train-traineeプロジェクトに参加する研修生の皆さんへ向けた開発ガイドラインです。
このプロジェクトを通じて、実践的なWebアプリケーション開発スキルを身につけていただくことを目的としています。

### 1.1 このプロジェクトで学べること

- **Spring Boot** によるWebアプリケーション開発
- **MVC パターン** の実装と理解
- **Thymeleaf** テンプレートエンジンによるUI開発
- **フォーム制御** の実装（プルダウン、ラジオボタン、チェックボックス等）
- **データベース設計** とSQLの実践（特にJOIN操作）
- **N+1問題** などのパフォーマンス最適化
- **論理削除** の実装パターン
- **バリデーション** とエラーハンドリング
- **日本語UI** の実装

### 1.2 参考資料・リファレンス

#### 公式ドキュメント
- [Maven公式ドキュメント](https://maven.apache.org/guides/index.html)
- [Spring Boot Maven Plugin](https://docs.spring.io/spring-boot/3.4.8/maven-plugin)
- [Spring Web](https://docs.spring.io/spring-boot/3.4.8/reference/web/servlet.html)
- [Spring Data JPA](https://docs.spring.io/spring-boot/3.4.8/reference/data/sql.html#data.sql.jpa-and-spring-data)
- [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.4.8/reference/using/devtools.html)

#### 実践ガイド
- [RESTful Web Service構築](https://spring.io/guides/gs/rest-service/)
- [Spring MVCによるWebコンテンツ提供](https://spring.io/guides/gs/serving-web-content/)
- [Spring RESTサービス構築](https://spring.io/guides/tutorials/rest/)
- [JPAによるデータアクセス](https://spring.io/guides/gs/accessing-data-jpa/)

#### コンテナ化
- [OCI（Docker）イメージ作成](https://docs.spring.io/spring-boot/3.4.8/maven-plugin/build-image.html)

## 2. 開発を始める前に

### 2.1 必要な知識

#### 基礎知識（必須）
- Java の基本文法
- オブジェクト指向プログラミングの基礎
- SQLの基本操作（SELECT, INSERT, UPDATE, DELETE）
- HTMLの基礎

#### あると望ましい知識
- Spring Framework の基礎
- JPA/Hibernate の基礎
- Thymeleaf テンプレートエンジンの基礎
- CSS の基礎
- Git の基本操作

### 2.2 開発環境のセットアップ

```bash
# 1. PostgreSQLデータベースの起動
docker run -d \
  -p 5432:5432 \
  -e POSTGRES_USER=trainee \
  -e POSTGRES_PASSWORD=trainee \
  -e POSTGRES_DB=trainee \
  --name trainee-postgres \
  postgres:15

# 2. アプリケーションの起動
./mvnw spring-boot:run

# 3. ブラウザでアクセス
# http://localhost:8080
```

## 3. アーキテクチャの理解

### 3.1 レイヤー構造

```
┌─────────────────────────────────────┐
│     View Layer (Thymeleaf)          │  ← ユーザーインターフェース
├─────────────────────────────────────┤
│   Controller Layer                  │  ← リクエスト処理・レスポンス生成
├─────────────────────────────────────┤
│    Service Layer                    │  ← ビジネスロジック
├─────────────────────────────────────┤
│   Repository Layer                  │  ← データアクセス
├─────────────────────────────────────┤
│     Entity Layer                    │  ← データモデル
├─────────────────────────────────────┤
│     Database (PostgreSQL)           │  ← データ永続化
└─────────────────────────────────────┘
```

### 3.2 各レイヤーの責務

#### Controller層
- HTTPリクエストの受け取り
- バリデーションの実行
- Serviceの呼び出し
- View（テンプレート）へのデータ受け渡し

#### Service層
- ビジネスロジックの実装
- トランザクション管理
- 複数のRepositoryの協調
- エラーハンドリング

#### Repository層
- データベースアクセス
- JPQL/SQLクエリの実装
- エンティティの永続化

## 4. 重要な実装パターン

### 4.1 N+1問題の解決

**N+1問題とは？**
データベースへのクエリが大量に発生してしまうパフォーマンス問題です。

**シンプルな例:**

❌ **悪い例（N+1問題が発生）:**
```java
List<User> users = getUsers();              // 1回のクエリ
for (User user : users) {
    user.getTags();                          // ユーザーごとに1回のクエリ（N回）
}
// 合計: 1 + N 回のクエリ（ユーザーが100人なら101回！）
```

✅ **良い例（バッチフェッチで解決）:**
```java
List<User> users = getUsers();                          // 1回のクエリ
List<Long> userIds = users.stream()
    .map(User::getId)
    .toList();
List<Tag> allTags = getTagsForUserIds(userIds);        // 1回のクエリ（WHERE user_id IN (1,2,3...)）
// 合計: 2回のクエリのみ（ユーザーが100人でも2回だけ！）
```

**実際のコード例（このプロジェクト）:**
```java
// ページ内の全ユーザーのタグをバッチで取得（N+1問題解決）
public Page<User> getAllUsers(int page, int size) {
    // ユーザーを取得（1クエリ）
    Page<User> userPage = userRepository.findAll(pageable);
    
    if (!userPage.getContent().isEmpty()) {
        // 全ユーザーのタグを一度に取得（1クエリ）
        List<Long> userIds = userPage.getContent().stream()
            .map(User::getId)
            .toList();
        List<UserTag> allTags = userTagRepository.findActiveByUserIds(userIds);
        
        // タグをユーザー別にグルーピングしてセット
        Map<Long, List<UserTag>> tagsByUserId = allTags.stream()
            .collect(Collectors.groupingBy(tag -> tag.getUser().getId()));
        
        userPage.getContent().forEach(user -> 
            user.setUserTags(tagsByUserId.getOrDefault(user.getId(), new ArrayList<>()))
        );
    }
    
    return userPage;
}
```

### 4.2 論理削除パターン

```java
// エンティティに削除日時フィールドを追加
@Entity
@Where(clause = "deleted_at IS NULL")
public class User {
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    // 論理削除実行メソッド
    public void delete() {
        this.deletedAt = LocalDateTime.now();
    }
    
    // 削除状態チェックメソッド
    public boolean isDeleted() {
        return this.deletedAt != null;
    }
    
    // アクティブ状態チェックメソッド
    public boolean isActive() {
        return this.deletedAt == null;
    }
}

// Repositoryでアクティブなレコードのみ取得
@Query("SELECT u FROM User u WHERE u.deletedAt IS NULL")
Page<User> findAllActive(Pageable pageable);
```

### 4.3 バリデーション実装

#### エンティティレベルでのバリデーション
```java
@Entity
public class User {
    @NotBlank(message = "ユーザー名は必須です。")
    @Size(max = 100, message = "ユーザー名は100文字以内で入力してください。")
    private String userName;
    
    @Email(message = "正しいメールアドレス形式で入力してください。")
    private String email;
}
```

#### コントローラーでのバリデーション実行
```java
@PostMapping("/new")
public String registerUser(@Valid @ModelAttribute("user") User user,
                          BindingResult bindingResult,
                          Model model) {
    if (bindingResult.hasErrors()) {
        // エラーがある場合は入力画面に戻る
        addFormAttributes(model);
        return "users/registration";
    }
    // 正常処理
}
```

### 4.4 Pageクラスの活用

Spring Data の `Page` クラスを使うと、ページネーション処理が自動化されます：

```java
// Repositoryメソッド
Page<User> findAllActive(Pageable pageable);

// Serviceでの使用
public Page<User> getAllUsers(int page, int size) {
    Pageable pageable = PageRequest.of(page, size, 
        Sort.by(Sort.Direction.DESC, "createdAt"));
    Page<User> userPage = userRepository.findAllActive(pageable);
    
    // Pageから取得できる情報
    userPage.getContent();       // 現在のページのユーザーリスト
    userPage.getTotalElements(); // 全ユーザー数
    userPage.getTotalPages();    // 全ページ数
    userPage.getNumber();        // 現在のページ番号（0から始まる）
    userPage.hasNext();          // 次のページがあるか
    userPage.hasPrevious();      // 前のページがあるか
    
    return userPage;
}
```

## 5. UI開発（Thymeleaf）の実装パターン

### 5.1 基本的なThymeleafテンプレート構造

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title th:text="${pageTitle}">研修生管理システム</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="container">
        <!-- ヘッダー部分 -->
        <h1 th:text="${pageTitle}">ページタイトル</h1>
        
        <!-- メッセージ表示部分 -->
        <div th:if="${success}" class="alert alert-success" th:text="${success}"></div>
        <div th:if="${error}" class="alert alert-danger" th:text="${error}"></div>
        
        <!-- コンテンツ部分 -->
        <div th:replace="fragments/content :: content"></div>
    </div>
</body>
</html>
```

### 5.2 フォーム制御の実装

#### プルダウン（セレクトボックス）
```html
<!-- カテゴリー選択 -->
<select th:field="*{category}" class="form-select">
    <option value="">-- 選択してください --</option>
    <option th:each="category : ${categories}" 
            th:value="${category}" 
            th:text="${category}"></option>
</select>

<!-- エラーメッセージ表示 -->
<div th:if="${#fields.hasErrors('category')}" class="text-danger">
    <span th:errors="*{category}"></span>
</div>
```

#### ラジオボタン
```html
<!-- ステータス選択 -->
<div th:each="status : ${statuses}">
    <input type="radio" th:field="*{status}" th:value="${status}" 
           th:id="'status-' + ${status}">
    <label th:for="'status-' + ${status}" th:text="${status}"></label>
</div>
```

#### チェックボックス（単一）
```html
<!-- ニュースレター配信同意 -->
<input type="checkbox" th:field="*{newsletterAgreement}" id="newsletter">
<label for="newsletter">ニュースレター配信に同意する</label>
```

#### チェックボックス（複数選択）
```html
<!-- スキルタグ選択（最大4個まで） -->
<div class="skill-tags">
    <div th:each="skill : ${availableSkillAreas}">
        <input type="checkbox" name="selectedTags" th:value="${skill}" 
               th:id="'skill-' + ${skill}"
               th:checked="${#lists.contains(user.userTags, skill)}">
        <label th:for="'skill-' + ${skill}" th:text="${skill}"></label>
    </div>
</div>

<!-- JavaScript でタグ選択数制限 -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const checkboxes = document.querySelectorAll('input[name="selectedTags"]');
    const maxTags = 4;
    
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const checked = document.querySelectorAll('input[name="selectedTags"]:checked');
            if (checked.length > maxTags) {
                this.checked = false;
                alert('タグは最大' + maxTags + '個まで選択可能です。');
            }
        });
    });
});
</script>
```

### 5.3 一覧表示とページネーション

```html
<!-- ユーザー一覧テーブル -->
<table class="table">
    <thead>
        <tr>
            <th>ID</th>
            <th>ユーザー名</th>
            <th>メールアドレス</th>
            <th>カテゴリー</th>
            <th>ステータス</th>
            <th>タグ</th>
            <th>操作</th>
        </tr>
    </thead>
    <tbody>
        <tr th:each="user : ${users}">
            <td th:text="${user.id}"></td>
            <td th:text="${user.userName}"></td>
            <td th:text="${user.email}"></td>
            <td th:text="${user.category}"></td>
            <td th:text="${user.status}"></td>
            <td>
                <span th:each="tag, iterStat : ${user.userTags}" 
                      class="badge bg-secondary">
                    <span th:text="${tag.tagName}"></span>
                    <span th:if="${!iterStat.last}">, </span>
                </span>
            </td>
            <td>
                <a th:href="@{/users/{id}(id=${user.id})}" class="btn btn-info btn-sm">詳細</a>
                <a th:href="@{/users/{id}/edit(id=${user.id})}" class="btn btn-warning btn-sm">編集</a>
                <a th:href="@{/users/{id}/delete(id=${user.id})}" class="btn btn-danger btn-sm">削除</a>
            </td>
        </tr>
    </tbody>
</table>

<!-- ページネーション -->
<nav th:if="${totalPages > 1}">
    <ul class="pagination">
        <!-- 前のページ -->
        <li class="page-item" th:classappend="${currentPage == 0} ? 'disabled'">
            <a class="page-link" th:href="@{/users(page=${currentPage - 1}, size=${size})}">前へ</a>
        </li>
        
        <!-- ページ番号 -->
        <li th:each="pageNum : ${#numbers.sequence(0, totalPages - 1)}" 
            class="page-item" 
            th:classappend="${pageNum == currentPage} ? 'active'">
            <a class="page-link" th:href="@{/users(page=${pageNum}, size=${size})}" 
               th:text="${pageNum + 1}"></a>
        </li>
        
        <!-- 次のページ -->
        <li class="page-item" th:classappend="${currentPage + 1 >= totalPages} ? 'disabled'">
            <a class="page-link" th:href="@{/users(page=${currentPage + 1}, size=${size})}">次へ</a>
        </li>
    </ul>
</nav>
```

### 5.4 検索・フィルター機能

```html
<!-- 検索・フィルターフォーム -->
<form th:action="@{/users}" method="get" class="search-form">
    <div class="row">
        <!-- 検索キーワード -->
        <div class="col-md-4">
            <label for="search">検索キーワード</label>
            <input type="text" id="search" name="search" th:value="${search}" 
                   class="form-control" placeholder="名前やメールアドレスで検索">
        </div>
        
        <!-- カテゴリーフィルター -->
        <div class="col-md-3">
            <label for="category">カテゴリー</label>
            <select id="category" name="category" class="form-select">
                <option value="">-- すべて --</option>
                <option th:each="cat : ${categories}" 
                        th:value="${cat}" 
                        th:text="${cat}"
                        th:selected="${cat == selectedCategory}"></option>
            </select>
        </div>
        
        <!-- ステータスフィルター -->
        <div class="col-md-3">
            <label for="status">ステータス</label>
            <select id="status" name="status" class="form-select">
                <option value="">-- すべて --</option>
                <option th:each="stat : ${statuses}" 
                        th:value="${stat}" 
                        th:text="${stat}"
                        th:selected="${stat == selectedStatus}"></option>
            </select>
        </div>
        
        <!-- 検索ボタン -->
        <div class="col-md-2 d-flex align-items-end">
            <button type="submit" class="btn btn-primary">検索</button>
            <a th:href="@{/users}" class="btn btn-secondary ms-2">クリア</a>
        </div>
    </div>
</form>
```

### 5.5 バリデーションエラーの表示

```html
<!-- フォーム全体のエラーサマリー -->
<div th:if="${#fields.hasErrors('*')}" class="alert alert-danger">
    <h4>入力エラーがあります</h4>
    <ul>
        <li th:each="error : ${#fields.errors('*')}" th:text="${error}"></li>
    </ul>
</div>

<!-- フィールド個別のエラー表示 -->
<div class="form-group">
    <label for="userName">ユーザー名 <span class="required">*</span></label>
    <input type="text" th:field="*{userName}" id="userName" 
           class="form-control" 
           th:classappend="${#fields.hasErrors('userName')} ? 'is-invalid'">
    <div th:if="${#fields.hasErrors('userName')}" class="invalid-feedback">
        <span th:errors="*{userName}"></span>
    </div>
</div>
```

### 5.6 動的なUI制御（JavaScript）

```html
<script>
// スキル追加フォームの動的制御
function addSkillForm() {
    const skillsContainer = document.getElementById('skills-container');
    const skillCount = skillsContainer.children.length;
    
    const skillForm = document.createElement('div');
    skillForm.className = 'skill-form mb-3';
    skillForm.innerHTML = `
        <div class="row">
            <div class="col-md-5">
                <input type="text" name="userSkills[${skillCount}].skillName" 
                       class="form-control" placeholder="スキル名" required>
            </div>
            <div class="col-md-3">
                <select name="userSkills[${skillCount}].skillLevel" class="form-select" required>
                    <option value="">レベル選択</option>
                    <option value="0">未経験</option>
                    <option value="1">1年未満</option>
                    <option value="2">1-2年</option>
                    <option value="3">2-3年</option>
                    <option value="4">3-5年</option>
                    <option value="5">5年以上</option>
                </select>
            </div>
            <div class="col-md-3">
                <input type="number" name="userSkills[${skillCount}].experienceYears" 
                       class="form-control" placeholder="経験年数" min="0">
            </div>
            <div class="col-md-1">
                <button type="button" class="btn btn-danger btn-sm" onclick="removeSkillForm(this)">削除</button>
            </div>
        </div>
    `;
    
    skillsContainer.appendChild(skillForm);
}

function removeSkillForm(button) {
    button.closest('.skill-form').remove();
}

// リアルタイム検索
function setupLiveSearch() {
    const searchInput = document.getElementById('search');
    let searchTimeout;
    
    searchInput.addEventListener('input', function() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            const searchValue = this.value;
            if (searchValue.length > 2 || searchValue.length === 0) {
                // 3文字以上で検索実行
                document.querySelector('.search-form').submit();
            }
        }, 500);
    });
}

document.addEventListener('DOMContentLoaded', function() {
    setupLiveSearch();
});
</script>
```

## 6. コーディング規約

詳細なコーディング規約については、[5-4-コーディング規約.md](./5-4-コーディング規約.md) を参照してください。

### 主要なポイント

- **命名規則**: クラス名はPascalCase、メソッド・変数名はcamelCase、定数はUPPER_SNAKE_CASE
- **インポート文**: ワイルドカード禁止、未使用インポートは削除
- **コメント**: 日本語で「なぜ」を説明、Javadocを活用
- **エラーハンドリング**: 適切な例外処理とログ出力
- **非推奨コード**: 最新のAPIを使用（`@SQLRestriction`、`@MockitoBean`など）

### エラーハンドリングのベストプラクティス

エラーハンドリングはアプリケーションの品質に直結する重要な要素です。
以下の基本パターンに従ってください：

1. **サービス層**: ビジネスロジック例外と技術的例外を区別
2. **コントローラー層**: ユーザーフレンドリーなエラーメッセージを提供
3. **ログ出力**: エラーレベルに応じた適切なログ記録

詳細な実装パターンは [5-4-コーディング規約.md#8-エラーハンドリング規約](./5-4-コーディング規約.md#8-エラーハンドリング規約) を参照してください。

## 7. よくある間違いと対処法

### 7.1 トランザクション管理の忘れ

❌ **間違い:**
```java
public class UserService {
    // @Transactionalアノテーションがない！
    public void updateUser(Long id, User user) {
        // 複数のDB操作が一貫性を保てない
    }
}
```

✅ **正しい実装:**
```java
@Service
@Transactional // クラスレベルで指定
public class UserService {
    // または
    @Transactional
    public void updateUser(Long id, User user) {
        // トランザクション内で実行される
    }
}
```

### 7.2 nullチェックの不足

❌ **間違い:**
```java
public String getUserName(Long userId) {
    User user = userRepository.findById(userId).get(); // NullPointerException の可能性！
    return user.getUserName();
}
```

✅ **正しい実装:**
```java
public String getUserName(Long userId) {
    return userRepository.findById(userId)
        .map(User::getUserName)
        .orElseThrow(() -> new IllegalArgumentException("ユーザーが見つかりません"));
}
```

### 7.3 SQLインジェクション対策

❌ **危険な実装:**
```java
// 文字列結合でSQLを構築してはいけない！
String sql = "SELECT * FROM users WHERE name = '" + userName + "'";
```

✅ **安全な実装:**
```java
// パラメータバインディングを使用
@Query("SELECT u FROM User u WHERE u.userName = :userName")
Optional<User> findByUserName(@Param("userName") String userName);
```

### 7.4 遅延ローディングの理解不足

JPA/Hibernateでは、`@OneToMany(fetch = FetchType.LAZY)` の場合、関連エンティティへのアクセス時にSQLが実行されます：

```java
// このコードは見た目はシンプルだが...
User user = userRepository.findById(id).get();
List<UserTag> tags = user.getUserTags(); // ← ここで追加のSQLクエリが実行される！

// これがループ内で実行されるとN+1問題になる
for (User user : users) {
    user.getUserTags(); // ← ユーザーごとにSQLが実行される
}
```

## 8. デバッグのコツ

### 8.1 ログの活用

```java
// 処理の開始と終了をログ出力
logger.debug("ユーザー検索開始: userId={}", userId);
try {
    User user = userService.getUserById(userId);
    logger.debug("ユーザー検索成功: {}", user);
    return user;
} catch (Exception e) {
    logger.error("ユーザー検索失敗: userId={}", userId, e);
    throw e;
}
```

### 8.2 SQL ログの確認

```properties
# application.properties に追加
spring.jpa.show-sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

### 8.3 ブレークポイントの活用

1. IDEでブレークポイントを設定
2. デバッグモードで起動
3. 変数の値を確認しながらステップ実行

## 9. データベース操作のベストプラクティス

### 9.1 JOINクエリの実装
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    /**
     * ユーザー名またはメールアドレスでの部分一致検索
     * JOINを使用してタグ情報も含めて検索
     */
    @Query("SELECT DISTINCT u FROM User u " +
           "LEFT JOIN u.userTags ut " +
           "WHERE (LOWER(u.userName) LIKE LOWER(CONCAT('%', :search, '%')) " +
           "   OR LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')) " +
           "   OR LOWER(ut.tagName) LIKE LOWER(CONCAT('%', :search, '%'))) " +
           "   AND u.deletedAt IS NULL")
    Page<User> findBySearchTerm(@Param("search") String search, Pageable pageable);
}
```

## 10. 学習リソース

### 10.1 推奨ドキュメント

- [Spring Boot 公式ドキュメント](https://spring.io/projects/spring-boot)
- [Spring Data JPA リファレンス](https://spring.io/projects/spring-data-jpa)
- [Thymeleaf チュートリアル](https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html)

### 10.2 このプロジェクトで学ぶべき重要概念

1. **依存性注入（DI）**: @Autowired の理解
2. **AOP**: @Transactional の動作原理
3. **ORM**: エンティティとテーブルのマッピング
4. **遅延ローディング**: FetchType.LAZY の動作
5. **セキュリティ**: SQLインジェクション対策、バリデーション

### 10.3 次のステップ

このプロジェクトをマスターしたら、以下に挑戦してみましょう：

1. **Spring Security** の導入（認証・認可）
2. **REST API** の実装
3. **単体テスト** の作成（JUnit, Mockito）
4. **CI/CD** パイプラインの構築
5. **Docker** コンテナ化

## 11. トラブルシューティング

### 11.1 よくあるエラーと解決方法

#### データベース接続エラー
```
Error: Connection refused
解決: PostgreSQLが起動しているか確認
$ docker ps
$ docker start trainee-postgres
```

#### ポート競合エラー
```
Error: Port 8080 is already in use
解決: 別のアプリケーションがポートを使用していないか確認
$ lsof -i:8080
$ kill -9 <PID>
```

#### Flywayマイグレーションエラー
```
Error: Migration checksum mismatch
解決: 開発環境の場合はデータベースをリセット
$ docker exec -it trainee-postgres psql -U trainee -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
```

## 12. コードレビューチェックリスト

新機能を実装したら、以下をチェックしてからプルリクエストを作成しましょう：

- [ ] コードにコメントを追加したか（特に複雑なロジック）
- [ ] エラーハンドリングを実装したか
- [ ] ログ出力を適切に追加したか
- [ ] バリデーションを実装したか
- [ ] N+1問題が発生していないか確認したか
- [ ] トランザクション管理は適切か
- [ ] nullチェックを実装したか
- [ ] コーディング規約（[5-4-コーディング規約.md](./5-4-コーディング規約.md)）に従っているか

## まとめ

このプロジェクトは、実践的なWebアプリケーション開発の基礎を学ぶための教材です。
コードを読んで理解するだけでなく、実際に手を動かして機能を追加・改善してみてください。

### 重要なポイント
1. **コメントは「なぜ」を説明する** - コードを読む人が理解しやすくする
2. **N+1問題を意識する** - データベースクエリの効率性を考慮する
3. **論理削除とページネーション** - 実用的なデータ操作パターンを身につける

**学習のコツ：**
- エラーを恐れずに、たくさん試してみる
- 分からないことは調べる習慣をつける
- コードレビューを通じて学ぶ
- 小さな改善を積み重ねる

頑張ってください！質問があれば、遠慮なく先輩開発者に聞いてください。
継続的な学習と実践により、より良いコードを書けるようになります。

## 10. 学習リソース

### 10.1 推奨ドキュメント

- [Spring Boot 公式ドキュメント](https://spring.io/projects/spring-boot)
- [Spring Data JPA リファレンス](https://spring.io/projects/spring-data-jpa)
- [Thymeleaf チュートリアル](https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html)